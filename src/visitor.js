class CheckerContext {
  constructor(visitor, filePath, sourceString) {
    this.visitor = visitor;
    this.filePath = filePath;
    this.sourceString = sourceString;
  }

  /// @brief Convert node's location into deepsource compatible format
  formatPosition(loc) {
    // a `loc` attached to an ESTree node can either be a `SourceLocation` object
    // or a `Position` object. However deepsource requires all location info
    // to be in a uniform format.

    // `loc` is a SourceLocation.
    if (loc.start) {
      return {
        begin: {
          line: loc.start.line,
          column: loc.start.column,
        },

        end: {
          line: loc.end.line,
          column: loc.end.column
        }
      }
    }

    return {
      begin: {
        line: loc.line,
        column: loc.column
      },

      end: {
        line: loc.line,
        column: loc.column
      }
    }
  }

  /// @brief Make a report compatible with deepsource.
  formatReport(reportDesc) {
    const position = this.formatPosition(reportDesc.loc);

    // TODO (injuly): Add issue codes too!
    const dsReport = {};
    dsReport.issue_text = reportDesc.message;
    dsReport.issue_code = '404';
    dsReport.location = {
      path: this.filePath,
      position
    }
    return dsReport;
  }

  report(reportDesc) {
    const finalReport = this.formatReport(reportDesc);
    this.visitor.collectReport(finalReport);
  }
}


class ASTVisitor {
  // @param {Check[]} checks List of check classes to use
  constructor(filePath, source, checks) {
    this.checks = checks || [];
    for (const check of this.checks) {
      this.addRule(check);
    }

    this.filePath = filePath;
    this.context = new CheckerContext(this, filePath, source);

    // @brief `checksForNodeType[x]` returns a list of all checks that are
    // concerned with the node type `x`.
    this.checksForNodeType = {};

    // @brief A list of reports generated by the checks.
    this.reports = [];
  }

  // @param {Check} check A check to add
  addCheck(check) {
    for (const nodeName of check.nodesToVisit) {
      if (!this.checksForNodeType[nodeName]) {
        this.checksForNodeType[nodeName] = [];
      }
      this.checksForNodeType[nodeName].push(check);
    }
  }

  collectReport(report) {
    this.reports.push(report);
  }

  logReports(log = console.log) {
    log(`In ${this.filePath}: `);
    this.reports.forEach(report => {
      const { begin } = report.location.position;
      const fmt = `Ln ${begin.line}, Col ${begin.column}: ${report.issue_text}`;
      log(fmt);
    });
  }

  // @param {Node|undefined} node An AST Node
  visit(node) {
    if (!node) return;

    const { type } = node;
    // 1. Look for all rules that are concerned with this node type
    // and call them.
    const checksForNode = this.checksForNodeType[type];
    if (checksForNode) {
      for (const check of checksForNode) {
        check[type](this.context, node);
      }
    }

    // 2. Call the visitor's own function for this node type.
    // TODO (injuly): Once all the nodes are covered in our visitor,
    // this `if` statement should be replaced with an assertion.
    if (this[type]) {
      this[type](node);
    }
  }

  Program(node) {
    for (const stat of node.body) {
      this.visit(stat);
    }
  }

  VariableDeclaration(node) {
    for (const decl of node.declarations) {
      this.visit(decl);
    }
  }

  VariableDeclarator(node) {
    this.visit(node.id);
    this.visit(node.init);
  }

  ArrayExpression(node) {
    for (const el of node.elements) {
      this.visit(el);
    }
  }

  BlockStatement(node) {
    for (const stat of node.body) {
      this.visit(stat);
    }
  }

  ExpressionStatement(node) {
    this.visit(node.expression);
  }

  AssignmentExpression(node) {
    this.visit(node.left);
    this.visit(node.right);
  }

  MemberExpression(node) {
    this.visit(node.object);
    this.visit(node.property);
  }

  ObjectExpression(node) {
    for (const property of node.properties) {
      this.visit(property);
    }
  }

  Property(node) {
    this.visit(node.key);
    this.visit(node.value);
  }

  CallExpression(node) {
    this.visit(node.callee);
    for (const arg of node.arguments) {
      this.visit(arg);
    }
  }
}

module.exports = ASTVisitor;
